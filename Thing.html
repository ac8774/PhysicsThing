<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0'>

  <title>Thing</title>
  <script src="liquidfun.js"></script>
  <style type="text/css">
    html,
    body {
      height: 100%;
      margin: 0 0;
      overflow: hidden
    }
  </style>

</head>

<body>
  <canvas id="canvas"></canvas>

  <script>
    var ctx = canvas.getContext('2d');
    var camera = {
      x: 0,
      y: 0,
      s: 1
    };
    setupWorld();
    nextFrame();


    function nextFrame() {
      world.Step(1 / 60, 8, 3);


      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      camera.x = canvas.width / 2;
      camera.y = canvas.height / 2
      camera.s = Math.min(canvas.width / 21, canvas.height / 21);


      ctx.lineWidth = 0.15;
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.save();
      ctx.translate(camera.x, camera.y);
      ctx.scale(camera.s, camera.s);
      for (var i = 0; i < world.bodies.length; i++) {
        var b = world.bodies[i]
        ctx.save();
        ctx.translate(b.GetTransform().p.x, -b.GetTransform().p.y)
        ctx.rotate(-b.GetAngle());
        for (var j = 0; j < b.fixtures.length; j++) {
          var s = b.fixtures[j].shape;
          if (s.render) {
            ctx.save();
            if (s.position) {
              ctx.translate(s.position.x, -s.position.y);
            }
            s.render();
            ctx.restore();
          }
        }
        ctx.restore();
      }
      ctx.restore();


      requestAnimationFrame(nextFrame);
    }

    function setupWorld() {
      var gravity = new b2Vec2(0, -10);
      world = new b2World(gravity);

      var bd = new b2BodyDef;
      g_groundBody = world.CreateBody(bd);

      newEdge(-10, -10, 10, -10);
      newEdge(-10, -10, -10, 10);
      newEdge(10, -10, 10, 10);
      newEdge(-10, 10, 10, 10);

      b2EdgeShape.prototype.render = function() {
        ctx.beginPath();
        ctx.moveTo(this.vertex1.x, -this.vertex1.y);
        ctx.lineTo(this.vertex2.x, -this.vertex2.y);
        ctx.stroke();
      };

      b2CircleShape.prototype.render = function() {
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, 2 * Math.PI);
        ctx.stroke();
      };

      b2PolygonShape.prototype.render = function() {
        ctx.beginPath();
        ctx.moveTo(this.vertices[0].x, -this.vertices[0].y);
        for (var v = 1; v < this.vertices.length; v++) {
          ctx.lineTo(this.vertices[v].x, -this.vertices[v].y)
        }
        ctx.closePath();
        ctx.stroke();
      };
    }

    function resetWorld() {

    }

    function newEdge(x1, y1, x2, y2) {
      var edge = new b2EdgeShape();
      edge.Set(new b2Vec2(x1, y1), new b2Vec2(x2, y2));
      var bd = new b2BodyDef();
      var body = world.CreateBody(bd);
      body.CreateFixtureFromShape(edge);
    }

    function newCircle(r = 1, x = 0, y = 1, density = 1) {
      var circle = new b2CircleShape();
      circle.radius = r;
      var bd = new b2BodyDef();
      bd.type = b2_dynamicBody;
      bd.position.Set(x, y);
      var body = world.CreateBody(bd);
      body.CreateFixtureFromShape(circle, density);
    }

    function newSquare(r = 1, x = 0, y = 1, density = 1) {
      var box = new b2PolygonShape();
      box.SetAsBoxXY(r, r);
      var bd = new b2BodyDef();
      bd.type = b2_dynamicBody;
      bd.position.Set(x, y);
      var body = world.CreateBody(bd);
      body.CreateFixtureFromShape(box, density);
    }


    function QueryCallback(point) {
      this.point = point;
      this.fixtures = [];
    }
    QueryCallback.prototype.ReportFixture = function(fixture) {
      if (fixture.TestPoint(this.point)) {
        this.fixtures.push(fixture);
      }
      return false;
    };

    function fixturesAt(p) {
      var aabb = new b2AABB;
      var d = new b2Vec2;
      d.Set(0.01, 0.01);
      b2Vec2.Sub(aabb.lowerBound, p, d);
      b2Vec2.Add(aabb.upperBound, p, d);

      var queryCallback = new QueryCallback(p);
      world.QueryAABB(queryCallback, aabb);
      return queryCallback.fixtures;
    }

    canvas.addEventListener('mousedown', mouseJointStart);
    canvas.addEventListener('touchstart', mouseJointStart);

    window.addEventListener('mousemove', mouseJointMove);
    window.addEventListener('touchmove', mouseJointMove);

    window.addEventListener('mouseup', mouseJointRemove);
    window.addEventListener('touchend', mouseJointRemove);

    var mouseJoints = []

    function mouseJointStart(event) {
      event.preventDefault();
      var mouse = getAllMouseCoords(event)[0];
      var p = mouse.p;
      var fixtures = fixturesAt(p);

      if (fixtures.length > 0 && fixtures[0].body.GetType() === b2_dynamicBody) {
        var body = fixtures[0].body;
        var md = new b2MouseJointDef;
        md.bodyA = g_groundBody;
        md.bodyB = body;
        md.target = p;
        md.maxForce = 1000 * body.GetMass();
        if(mouseJoints[mouse.id])
        {
          world.DestroyJoint(mouseJoints[mouse.id]);
        }
        mouseJoints[mouse.id] = world.CreateJoint(md);
        body.SetAwake(true);
      } else {
        newCircle(1, p.x, p.y);
        newSquare(1, p.x, p.y);
      }
    }

    function mouseJointMove(event) {
      mice = getAllMouseCoords(event);
      for(var m = 0; m<mice.length; m++)
      {
        mouse = mice[m];
        var p = mouse.p;
        if (mouseJoints[mouse.id]) {
          mouseJoints[mouse.id].SetTarget(p);
        }
      }
    }

    function mouseJointRemove(event) {
      event.preventDefault();
      var mouse = getAllMouseCoords(event)[0];
      if (mouseJoints[mouse.id]) {
        world.DestroyJoint(mouseJoints[mouse.id]);
        mouseJoints[mouse.id] = null;
      }
    }

    function getAllMouseCoords(event) {
      if (event instanceof TouchEvent) {
        var ret = [];
        for (var touch = 0; touch < event.changedTouches.length; touch++)
        {
          ret.push({p:getMouseCoords(event.changedTouches[touch]), id:1+event.changedTouches[touch].identifier})
        }
        return ret;
      } else {
        return [{p:getMouseCoords(event), id: 0}]
      }
    }
    function getMouseCoords(e) {
      rect = canvas.getBoundingClientRect();
      x = (e.clientX - rect.left - camera.x) / camera.s;
      y = (camera.y - (e.clientY - rect.top)) / camera.s;
      return new b2Vec2(x, y);
    }
  </script>

</body>

</html>
