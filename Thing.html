<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width">

  <title>Thing</title>
  <script src="two.js"></script>
  <script src="blockly_compressed.js"></script>
  <script src="blocks_compressed.js"></script>
  <script src="javascript_compressed.js"></script>
  <script src="customBlocks.js"></script>
  <script src="en.js"></script>
  <script src="liquidfun.js"></script>
  <style type="text/css">
    html,
    body {
      height: 100%;
      margin: 0 0;
    }

    .panes-container {
      display: flex;
      width: 100%;
      height: 100%;
    }

    .left-pane {
      width: 50%;
      height: 100%;
    }

    .panes-separator {
      width: 15px;
      height: 100%;
      position: relative;
      cursor: col-resize;
    }

    .right-pane {
      height: 100%;
      flex: auto;
    }

    #top-bar {
      height: 100px;
      background: #eee;
    }

    #graphics-output {
      background: #555;
    }

    #bottom-bar {
      height: 300px;
      background: #eee;
    }

    #textarea {
      overflow: auto;
      height: 100%;
    }

    .bar {}
  </style>

</head>

<body>
  <div class="panes-container" id="panes-container">
    <div class="left-pane" id="left-pane">
      <div class="bar" id="top-bar">
        <button onclick="showCode()">Show JavaScript</button>
        <button onclick="runCode()">Run JavaScript</button>
      </div>
      <div id="graphics-output"></div>
      <div class="bar" id="bottom-bar">
        <div id="textarea"></div>
      </div>
    </div>
    <div class="panes-separator" id="panes-separator"></div>
    <div class="right-pane" id="right-pane">
      <div id="blocklyArea" style="height: 100%; width: 100%"></div>
    </div>
  </div>

  <xml id="toolbox" style="display: none;">
    <block type="statement">
      <field name="code">//JavaScript statement</field>
    </block>
    <block type="expression">
      <field name="code">"JavaScript expression"</field>
    </block>
    <block type="new_shape">
      <field name="shape">circle</field>
      <value name="x">
        <block type="expression">
          <field name="code">0</field>
        </block>
      </value>
      <value name="y">
        <block type="expression">
          <field name="code">1</field>
        </block>
      </value>
      <value name="r">
        <block type="expression">
          <field name="code">1</field>
        </block>
      </value>
      <value name="color">
        <block type="colour_picker">
          <field name="COLOUR">#ff0000</field>
        </block>
      </value>
    </block>
  </xml>


  <script>
    var leftPane = document.getElementById('left-pane');
    var rightPane = document.getElementById('right-pane');
    var paneSep = document.getElementById('panes-separator');
    var blocklyArea = document.getElementById('blocklyArea');
    var graphicsOutput = document.getElementById('graphics-output');
    var workspace = Blockly.inject(blocklyArea, {
      media: 'BlocklyMedia/',
      toolbox: document.getElementById('toolbox')
    });
    var two = new Two({
      type: Two.Types.webgl
    }).appendTo(graphicsOutput);
    var layer;

    setupResizing();
    setupWorld();

    function resizePage() {
      Blockly.svgResize(workspace)
      two.renderer.setSize(leftPane.offsetWidth, leftPane.offsetHeight - 400);
      two.width = leftPane.offsetWidth
      two.height = leftPane.offsetHeight - 404
    }

    function resizePanes(e) {
      var pos = (e.pageX || e.touches[0].screenX) / window.innerWidth * 100;
      if (pos < 22) {
        pos = 20;
      }
      if (pos > 78) {
        pos = 80;
      }
      leftPane.style.width = pos + '%';
      resizePage();
    }

    function setupResizing() {
      paneSep.addEventListener('mousedown', function(e) {
        window.addEventListener('mousemove', resizePanes);
      });
      window.addEventListener('mouseup', function(e) {
        window.removeEventListener('mousemove', resizePanes);
      });
      paneSep.addEventListener('touchstart', function(e) {
        window.addEventListener('touchmove', resizePanes);
      });
      window.addEventListener('touchend', function(e) {
        window.removeEventListener('touchmove', resizePanes);
      });
      window.addEventListener('resize', resizePage);
      resizePage();
    }

    function showCode() {
      Blockly.JavaScript.INFINITE_LOOP_TRAP = null;
      var code = Blockly.JavaScript.workspaceToCode(workspace);
      alert(code);
      //document.getElementById("textarea").innerHTML = code.split('\n').join('<br>');
    }

    function runCode() {
      window.LoopTrap = 1000;
      Blockly.JavaScript.INFINITE_LOOP_TRAP =
        'if (--window.LoopTrap == 0) throw "Infinite loop.";\n';
      var code = Blockly.JavaScript.workspaceToCode(workspace);
      Blockly.JavaScript.INFINITE_LOOP_TRAP = null;
      try {
        eval(code);
      } catch (e) {
        alert(e);
      }
    }

    function nextFrame() {
      world.Step(1 / 60, 8, 3);
      layer.translation.set(two.width / 2, two.height / 2);
      for (var i = 0; i < layer.children.length; i++) {
        if (world.bodies[i].GetType() > 0) {
          layer.children[i].translation.set(world.bodies[i].GetTransform().p.x, -world.bodies[i].GetTransform().p.y);
          layer.children[i].rotation = -world.bodies[i].GetAngle();
        }
      }

      layer.scale = Math.min(two.width / 80, two.height / 60);

      two.update();

      requestAnimationFrame(nextFrame);
    }

    function setupWorld() {
      layer = two.makeGroup();
      var gravity = new b2Vec2(0, -10);
      world = new b2World(gravity);

      newEdge(-40, -30, 40, -30);
      newEdge(-40, -30, -40, 30);
      newEdge(40, -30, 40, 30);
      newEdge(-40, 30, 40, 30);

      nextFrame();
    }

    function resetWorld() {

    }

    function newEdge(x1, y1, x2, y2) {
      var bd = new b2BodyDef();
      var ground = world.CreateBody(bd);
      var edge = new b2EdgeShape();
      edge.Set(new b2Vec2(x1, y1), new b2Vec2(x2, y2));
      ground.CreateFixtureFromShape(edge);
      layer.add(two.makeLine(x1, y1, x2, y2));
    }

    function newCircle(r = 1, x = 0, y = 1, color = "", density = 1) {
      var circle = new b2CircleShape();
      circle.radius = r;
      bd = new b2BodyDef();
      bd.type = b2_dynamicBody;
      bd.position.Set(x, y);
      var body = world.CreateBody(bd);
      body.CreateFixtureFromShape(circle, density);
      var c = two.makeCircle(0, 0, r);
      c.noStroke();
      c.fill = color == "" ? '#' + Math.floor(Math.random() * 16777215).toString(16) : color;
      layer.add(c);
    }

    function newSquare(r = 1, x = 0, y = 1, color = "", density = 1) {
      var box = new b2PolygonShape();
      box.SetAsBoxXY(r, r);
      bd = new b2BodyDef();
      bd.type = b2_dynamicBody;
      bd.position.Set(x, y);
      var body = world.CreateBody(bd);
      body.CreateFixtureFromShape(box, density);
      var c = two.makeRectangle(0, 0, 2 * r, 2 * r);
      c.noStroke();
      c.fill = color == "" ? '#' + Math.floor(Math.random() * 16777215).toString(16) : color;
      layer.add(c);
    }


    /**@constructor*/
    function QueryCallback(point) {
      this.point = point;
      this.fixture = null;
    }

    /**@return bool*/
    QueryCallback.prototype.ReportFixture = function(fixture) {
      var body = fixture.body;
      if (body.GetType() === b2_dynamicBody) {
        var inside = fixture.TestPoint(this.point);
        if (inside) {
          this.fixture = fixture;
          return true;
        }
      }
      return false;
    };
    that = {};
    var bd = new b2BodyDef;
    g_groundBody = world.CreateBody(bd);
    layer.add(two.makeGroup());
    graphicsOutput.addEventListener('mousedown', mouseJointStart);
    graphicsOutput.addEventListener('touchstart', mouseJointStart);

    window.addEventListener('mousemove', mouseJointMove);
    window.addEventListener('touchmove', mouseJointMove);

    window.addEventListener('mouseup', mouseJointRemove);
    window.addEventListener('touchend', mouseJointRemove);

    function mouseJointStart(event) {
      event.preventDefault();
      var p = getMouseCoords(event);
      var aabb = new b2AABB;
      var d = new b2Vec2;

      d.Set(0.01, 0.01);
      b2Vec2.Sub(aabb.lowerBound, p, d);
      b2Vec2.Add(aabb.upperBound, p, d);

      var queryCallback = new QueryCallback(p);
      world.QueryAABB(queryCallback, aabb);

      if (queryCallback.fixture) {
        var body = queryCallback.fixture.body;
        var md = new b2MouseJointDef;
        md.bodyA = g_groundBody;
        md.bodyB = body;
        md.target = p;
        md.maxForce = 1000 * body.GetMass();
        that.mouseJoint = world.CreateJoint(md);
        body.SetAwake(true);
      } else
        newCircle(1, p.x, p.y); // temporary
    }

    function mouseJointMove(event) {
      event.preventDefault();
      var p = getMouseCoords(event);
      if (that.mouseJoint) {
        that.mouseJoint.SetTarget(p);
      }
    }

    function mouseJointRemove(event) {
      event.preventDefault();
      if (that.mouseJoint) {
        world.DestroyJoint(that.mouseJoint);
        that.mouseJoint = null;
      }
    }

    function getMouseCoords(event) {
      if (event instanceof TouchEvent) {
        e = event.touches[0]
      } else e = event;
      rect = graphicsOutput.getBoundingClientRect();
      x = (e.clientX - rect.left - layer.translation._x) / layer.scale;
      y = (layer.translation._y - (e.clientY - rect.top)) / layer.scale;
      return new b2Vec2(x, y);
    }
  </script>

</body>

</html>
